from faker import Faker

import pytest

from app import app
from strapi_model_mixin import *

fake = Faker()


@pytest.fixture
def client():
    app.config["TESTING"] = True
    with app.test_client() as client:
        yield client


def test_get_all_entries(client):
    response = client.get(
        '/messages?sort=content&filters={"content": "value"}&pagination={"limit": 10}&get_all=true'
    )
    assert response.status_code == 200


# The fixture for the client is already defined in your previous code.


# Test 1: Fetching all messages with no extra parameters.
def test_get_all_messages_no_params(client):
    response = client.get("/messages")
    assert response.status_code == 200


# Test 2: Fetching all messages, ignoring pagination (if get_all=True is supported by your API).
def test_get_all_messages_get_all(client):
    response = client.get("/messages?get_all=true")
    assert response.status_code == 200


# Test 3: Fetching all messages, sorted by 'content' in ascending order.
def test_get_messages_sorted(client):
    response = client.get("/messages?sort=content")
    assert response.status_code == 200


# Test 4: Fetching messages filtered by a specific content.
def test_get_messages_filtered(client):
    filter_data = {"content": {"$eq": "Hello World!"}}
    response = client.get(f"/messages?filters={json.dumps(filter_data)}")
    assert response.status_code == 200


# Test 5: Fetching all messages and populating all related fields.
def test_get_messages_populate_all(client):
    response = client.get("/messages?populate=*")
    assert response.status_code == 200


# Test 6: Fetching all messages and selecting only the 'content' and 'createdAt' fields.
def test_get_messages_fields(client):
    response = client.get("/messages?fields=content,createdAt")
    assert response.status_code == 200


# Test 7: Fetching messages with pagination limited to 3 entries.
def test_get_messages_pagination(client):
    pagination_data = {"limit": 3}
    response = client.get(f"/messages?pagination={json.dumps(pagination_data)}")
    assert response.status_code == 200


# Test 8: Fetching messages in the 'preview' publication state.
def test_get_messages_publication_state(client):
    response = client.get("/messages?publication_state=preview")
    assert response.status_code == 200


# These are just example tests and they assume that your backend API behaves as expected.
# In a real-world scenario, you'd also want to check the content of the response, not just the status code.


def test_create_author(client):
    """
    Test case for creating an author via POST request using Faker for data generation.
    """
    # Generate fake data
    avatar = None  # Assuming avatar is not mandatory, keeping it as None
    email = fake.email()
    name = fake.name()

    # Prepare payload
    payload = {"avatar": avatar, "email": email, "name": name}

    # Make POST request and receive response
    response = client.post("/authors", json=payload)

    # Deserialize JSON response to Python dict
    data = json.loads(response.data)["data"]

    # Verification of response content
    assert data["attributes"]["email"] == email
    assert data["attributes"]["name"] == name
    assert (
        data["id"] is not None
    )  # Since the ID is usually autogenerated, just check if it's not None


def test_create_update_delete_author(client):
    """
    Test case for creating, updating, and deleting an author using POST, PATCH, and DELETE requests, respectively.
    """
    # Initialize Faker instance
    fake = Faker()

    # Generate initial fake data
    initial_avatar = None  # Assuming avatar is not mandatory, keeping it as None
    initial_email = fake.email()
    initial_name = fake.name()

    # Prepare initial payload
    initial_payload = {
        "avatar": initial_avatar,
        "email": initial_email,
        "name": initial_name,
    }

    # Create author
    create_response = client.post("/authors", json=initial_payload)
    create_data = json.loads(create_response.data)["data"]

    # Verify creation
    assert create_data["attributes"]["email"] == initial_email
    assert create_data["attributes"]["name"] == initial_name
    author_id = create_data["id"]
    assert author_id is not None

    # Generate updated fake data
    updated_email = fake.email()
    updated_name = fake.name()

    # Prepare update payload
    updated_payload = {"email": updated_email, "name": updated_name}

    # Update author
    update_response = client.put(f"/authors/{author_id}", json=updated_payload)
    update_data = json.loads(update_response.data)["data"]
    assert update_response.status_code == 200

    # Verify update
    assert update_data["attributes"]["email"] == updated_email
    assert update_data["attributes"]["name"] == updated_name

    # Delete author
    delete_response = client.delete(f"/authors/{author_id}")

    # Verify deletion
    assert delete_response.status_code == 200

    # Check if the author is actually deleted by trying to fetch it,
    # this will throw an error if the author is not found
    # assert the error is thrown

    try:
        fetch_response = client.get(f"/authors/{author_id}")
        assert fetch_response is None
    except Exception as world_ex:
        print(f"Exception caught: {world_ex}")
        assert True  # The world was deleted, so get_one should fail
